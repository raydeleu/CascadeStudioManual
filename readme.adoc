= CascadeStudio Manual
:docdate:
:experimental: 
:xrefstyle: short
:toc: 
:sectnums: 

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

== Introduction

=== Purpose
This document is intended to create a short introduction and manual for the software CascadeStudio, created by Johnathon Selstad (@zalo).

=== What is CascadeStudio?
CascadeStudio is a software package that allows the user to enter a kind of script to create a 3D model. This model can then be exported in several formats,  allowing the user to create nice images (renders) or to send the shape to a 3D printer.

The approach to model a 3D shape with code (or script) has become popular through the availability of a software package called OpenSCAD (Open Scripted-Computer-Aided-Design). OpenSCAD has been used initially to model simple shapes for 3D modelling. It uses a technique called Constructive Solid Geometry (CSG), which indicates that 3D shapes are created by combining simple geometric shapes such as boxes, spheres, cylinders into more complex shapes. The operations used to combine these shapes are called boolean operations.

---
._Simple car model created in OpenSCAD_
[#img-car-opencad]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/openscad-car.jpg[align="center"]
---

This shape is created by entering the following script:

.Code to create a car in OpenSCAD, using two boxes and 6 cylinders (4 wheels and two axles)

[source, javascript]
----
cube([60,20,10],center=true);
translate([5,0,10 - 0.001])
    cube([30,20,10],center=true);
translate([-20,-15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([-20,15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([20,-15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([20,15,0])
    rotate([90,0,0])
    cylinder(h=3,r=8,center=true);
translate([-20,0,0])
    rotate([90,0,0])
    cylinder(h=30,r=2,center=true);
translate([20,0,0])
    rotate([90,0,0])
    cylinder(h=30,r=2,center=true);
----

CascadeStudio takes this approach a step further. It still retains the approach that shapes are created with a simple script, but it uses a more advanced 3D kernel that allows BRep (Boundary Representation) modelling. In this type of 3D kernel a solid is represented as a collection of surface elements - described using a mathematical equation - that define the boundary between interior and exterior points.

The advantage of a BRep kernel is that in addition to the simple boolean operations it is possible to define how the surfaces are linked to each other. This allows a more easy creation of angled edges (chamfers) or rounded edges (fillets). 

---
._Example of CascadeStudio shape with fillets_
[#img-ccs-fillets]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/ccs-car-v2.png[align="center"]
---


=== Where can you find CascadeStudio?

CascadeStudio is offered as an open source software at the following github address:

https://github.com/zalo/CascadeStudio

Github is a website intended to develop code. It allows to download complete repositories, change parts and perform version control on the code. Github is especially suited to allow more developers to work on the same set of code files. This also means that you can download all code required to build the software and even create your own version (called "fork") from it.

Johnathon did not start from scratch but took some components that are available as open source as well. The most important components used to create CascadeStudio are:

* opencascade.js (CAD Kernel)
* Monaco Editor (Text Editing and Intellisense)
* Golden Layout (Windowing System)
* three.js (3D Rendering Engine)
* controlkit.js (Buttons/Sliders),
* opentype.js (Font Parsing)
* rawinflate/rawdeflate (URL Code Serialization)
* potpack (Texture Atlas Packing)

=== OpenCascade 3D kernel
CascadeStudio uses the OpenCascade 3D modelling CAD (computer aided design) kernel. This is the same kernel that is used in the FreeCad application. In many respects therefore the output of CascadeStudio is comparable to FreeCad.

The OpenCascade kernel was developed originally by a set of people that started as part of Matra Datavision. Their first CAD system called Euclid was already developed in 1980. This software has evolved an in the passing years the company changed hands several times, first to Areva, then EADS and since 2014 it is part of Capgemini.

The name Cascade is derived from CAS.CADE (Computer Aided Software for Computer Aided Design and Engineering). In 1999 Matra Datavision published CAS.CADE in open source on the Internet as Open CASCADE later renamed to Open CASCADE Technology.

https://www.opencascade.com/

It is interesting to note that the number of 3D kernels used worlwide is rather limited. The most well-known kernels are:

* ACIS by Spatial
* ShapeManager by Autodesk, which is in fact a fork from ACIS
* CGM (Convergence Geometric Modeller) also by Spatial and used in the famous CATIA software.
* Parasolid by Siemens
* C3D Toolkit by C3D Labs
* Open CASCADE

There are also kernels used for socalled Nurbs modelling, used by software packages such as Rhino and Moi3D (Moment of Inspiration). These kernels also use the BRep approach where the surfaces are described by socalled Non-Uniform Rational B-Splines (NURBS). The advantage of NURBS is that these are capable to describe both complex shapes and simple geometric shapes like lines and arcs.

Sometimes it is argued that a proper 3D kernel has infinite accuracy as the shapes are defined by mathematical equations that are continuous. While this seems a reasonable assumption, we should also consider how the 3D shape is used. During the creation of the part the person constructing the part uses a visualisation of the part on the computer screen. To produce this visualisation, the computer has to calculate the position of points and edges. This is not done with infinite accuracy. In CascadeStudio there is a slider that determines the "mesh-resolution". The default setting is 0.10 and provides a smooth image. If we increase the mesh-resolution, the mesh-resolution becomes in fact more coarse and circles show straight segments. 

After the design the part is often exported to a 3D printer or CNC machine in a socalled STL (stereolithography) model. In the STL format the shape is again represented by small faces. The granularity or resolution of these faces can often be indicated during the export. The smaller the resolution, the longer an export will take and the larger the resulting file will be. If the resolution of the produced file is visible in the end-product is determined both by the resolution of the data used to control the machine that is producing the part (or the mold for a part) and by the manufacturing process. For example, if a CNC (computer numerical control) mill is used to produce a part, the inner radii are often determined by the diameter of the tool that is used to mill the product. The radius will be very smooth as it is produced by a revolving tool (the socalled end-mill). 

If you want to know more on manufacturing techniques, many resources can be found on the internet. At https://www.making.unsw.edu.au/learn/ there are some short tutorials on different manufacturing techniques to produce your own part. 

// includes seem not to work on github readme
// include::https://github.com/raydeleu/CascadeStudioManual/blob/main/parametric_modelling.adoc[]

== Starting the program

=== On-line
It is possible to access a fully working version of CascadeStudio by browsing to the following internet address: https://zalo.github.io/CascadeStudio/

Another alternative is to go to the cadhub website at https://cadhub.xyz/

If you sign up at this website it is possible to create a part in CascadeStudio and share this with other users. The site has a gallery of parts that can be studied to learn from the approaches other users have chosen to model their part. Examples can also be found at https://github.com/zalo/CascadeStudio/discussions/categories/show-and-tell but here it is not always possible to check the source code for each part. 

=== Local installation

==== Using a local web server
As the author has published CascadeStudio as an Open Source project, it is possible to download the complete source code from the github page mentioned above. Using the source code it is possible to install a local version on a webserver. Running the program "is as simple as running a server from the root directory (such as the VS Code Live Server, Python live-server, or Node live-server". 

The approach with the VS Code live server is indeed very simple. Follow these steps: 

. install VS Code from [https://code.visualstudio.com]
. Open VSCode and type kbd:[CMD]+ kbd:[P] to open the command palette and enter "ext install ritwickdey.liveserver". 
+

---
._Opening the command prompt in VS Code_
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/vscode_command.png[width=500]
---

. Alternatively you can open the extension sidebar which opens the Marketplace. If you enter "live server" a long list of extensions is shown. The server from ritwickdey will occur on top of the list as this is by far the most downloaded version. 
+
--
._Extension panel_
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/vscode_extensions.png[width=400]
--

. download the code of CascadeStudio from https://github.com/zalo/CascadeStudio by pressing the green "Code" button. Choose "Download ZIP". After downloading unpack the zip file somewhere in your file system. 
. In VS Code, go to "File" and choose the command "Add folder to workspace". Choose the folder "CascadeStudio-master" that you probably just created by unpacking the git repository. 
. Right-click on the file "index.html" and choose "Open with Live Server". In my case my standard browser opened the page "http://127.0.0.1:5500/index.html" and showed the interface to CascadeStudio. Be sure to add the parent directory to the file index.html as a workspace. If you add a parent folder as a workspace it is still possible to navigate to index.html, but the program will not function correctly. Most notably the help messages that should appear when you hover your mouse over a function do not work and it looks as if a lot of errors are found in the editor window (indicated by the red color in the right margin of the editor). 
+

--
._Starting the VS Code live server_ 
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/vscode_start_liveserver.png[width=400]
--

The server seems to run really inside VS Code, so if you quit VS Code the local version of CascadeStudio will also be shut down. 

==== Install CascadeStudio as a Progressive Web App
An even simpler approach is to install CascadeStudio as a Progressive Web App (PWA). A PWA is a local - almost native - application that can run even without an internet connection. This is achieved by installing a socalled "service worker" that continues to provide the functionality of a web application by using a local cache. To the user the PWA looks identical to a normal application that is installed on the computer. It can be installed in the applications folder and the icon can be shown on the desktop and task bar (or dock). 

To install CascadeStudio as a Web App perform the following steps: 

. Open the page https://zalo.github.io/cascadestudio/ 
. In the browser address bar, click on the "+" sign (MS Windows) or on the "download to computer" icon (MacOS). 
+
--
._Installing the web-app in Chrome browser_ 
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/install_button.png[width=300]
-- 

. In the dialog "Install App?" choose "Install"
+
--
._Dialog to install the web app_ 
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/install_app_dialog.png[]
-- 

. When the installation is complete the app can be found in the application folder of your web browser. For example, if you are using Chrome browser, it will be available as a Chrome App. 
+
--
._Location of the Chrome web app on MacOS_ 
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/chrome_apps.png[width=300]
-- 


''''
== Warnings before using CascadeStudio

=== Learning the coding concept to modelling will take time
CascadeStudio is a modeller that works with code as input. This approach is conceptually different from the approaches that most users will have encoutered before. But the differences are larger than only the user interaction. Modelling an object in 3D can be compared to solving a puzzle using the tools provided by the software. At a certain moment this becomes straightforward but it takes certainly time. Modelling with code makes this even a bit harder because there is no option to doodle with the tools. Every stroke of a pen requires entering coordinates of the begin and endpoint. And the equivalent of a pen stroke, a socalled wire or segment, is difficult to see in CascadeStudio as there is only a 3D window that relies on a realistic lighting simulation. CascadeStudio also lacks the concept of drawing in layers or collections that can be easily hidden or made transparant. So if you have started you object by roughly blocking it out by adding simple 3D shapes to your scene, it is not always easy to continue from there towards a more detailed object. So be prepared to learn the new concept and be aware that in the beginning each model will take more time to produce than can be achieved in other more intuitive programs. Keep your eyes on the reward that you will be able to produce very complex models with a very small tool that can be started locally in your browser. The price you pay for this tool is mostly your own time. And even if you do not pursue modelling with CascadeStudio further you will have learned a lot about coding, 3D modelling and perhaps even engineering in the process. So consider your time well spent!  

=== Apart from this document, there is no manual
Although CascadeStudio shows a lot of promise, it needs to be mentioned that the software is not straightforward to use. The author of the software did not (yet?) publish a user manual. Instead the users can use the IntelliSense feature of the Monaco Editor, where a short explanation is shown when the user hovers the mouse pointer over the function name that was just entered. This requires the user to know at least the names of the available functions. Another approach is to visit the code repository for the application and browse through the main library called "CascadeStudioStandardLibrary.js". To fill this gap, this document was written, using a trial and error approach to determine how the different functions are working. 

=== Finding errors in the code is difficult
Another drawback that users should consider is the difficulty of finding errors in the code. The program supplies error warnings, but these are not very informative and sometimes seem to have no relation at all to the code in the editor. 


._Errors displayed in the console window_
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/ccs_error.png[width=750]
''''

Pressing kbd:[F8] in the editor lets the cursor jump to the first error found. Note that the error displayed in the editor is often much more precise and contains more information on the possible cause of the error. Therefore the best advice is to use this method of debugging errors in the code and only use the console to determine if the build was succesful. 

._Errors displayed in the editor pane_ 
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/errors_F8.png[]

''''

Furthermore a good programming advice is to build the object in small steps, verifying after each step if an error was introduced. Note that the code is sensitive to missing brackets, so it is good practice to use proper indentation of the code to alleviate finding missing brackets.  

=== The program sometimes acts unpredictable
And finally there are situations where even returning to the previous, working code does not prevent the code from crashing. It might help to disable the caching functionality. If nothing helps, try to save your code to a separate text file and start over in a fresh interface. Other reasons for unexpected behaviour can be: 

* shapes that seem correct on the display are in fact faulty, for example due to lines that are not connected;  
* sketches form intersecting contours;
* boolean operations of shapes that have coplanar faces;
* fillets in corners that are too tight; 

The causes listed above will be explained later on in the document. Note that these issues are found in any CAD package and are not an indication of lacking software quality. Most of these are limits in the mathematical methods used to define the shape in 3D. The only caveat of CascadeStudio in this respect is that spotting these errors can be a little bit more difficult as the result of the definition of the shape is only visible after running the evaluation of the code. 


== First steps

=== The user interface
After starting the program the following interface is presented to the user: 

._Interface of CascadeStudio_
[#img-ccs-interface]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/interface.png[]

'''
The interface of CascadeStudio is relatively straightforward. The main window is split into three parts, namely:

* the code editor
* the 3D window
* the processing log 

The users enters the code to generate a 3D shape into the code editor. When the code is complete the program can be triggered by keying kbd:[F5] or clicking on the "Evaluate" button in the 3D window dialog. The processing log shows the result of the processing. If this log end with the message "Generation Complete!" the code most likely did not contain any errors. If there are errors in the code, the processing log will indicate what is wrong. Sometimes the line numbers of the error message make no sense. In that case it can help to analyse what shapes have been succesfully built or which command is mentioned in the error log. This can often indicate the line where the first error occured in the code. 

The shape in the 3D view can be manipulated with the mouse. Pressing the left mouse button (LMB) while dragging rotates the view, pressing the right mouse button (RMB) while dragging pans or shifts the field of view. Rolling the scroll wheel with the mouse pointer inside the 3D view zooms in and out. 

The menu bar contains the following items: 

Cascade Studio 0.0.7:: Opens the github page where the source code of the software can be found
Save project:: Opens a dialog to save the current code. The code is stored inside a json file, which is a plain ascii file. Note that this file contains much more information than only the code shown in the code editor. 
Load project:: Opens a dialog to browse for an earlier stored json file
Save STEP :: saves the current 3D model in the STEP format. STEP stands for "Standard for the Exchange of Product Data" and is a format defined in ISO 10303. It can describe a shape in terms of curves and faces. Additionally it can contain information on material, tolerances and colour of the object.   
SAVE STL:: saves the current 3D model in the STL format. STL or Stereo Lithography format describes the model with a mesh of triangle-shaped polygons. It is therefore an approximation of the 3D shape and may be considered a "lossy" format: data is lost in the conversion towards STL and the original format cannot be recovered from this format. 
SAVE OBJ:: saves the current 3D model in a Wavefront Object format. The OBJ format can contain both information on polygons and curves. It can therefore combine features of both the STEP format and the STL format. However, information on materials and tolerances are not included in the OBJ file. Other 3D programs offer the option to combine a material file with the OBJ file so that an object can be imported into a 3D software package with the correct texture and materials applied to the shape.
Import STEP/IGES/STL:: import a 3D shape in the STEP, IGES and STL format. OpenCascade can only read ASCII-encoded files, not binary encoded files. The imported shapes can be manipulated, but many of the construction commands cannot be applied to these shapes. 
Clear Imported Files:: This menu item clears the imported data from the current JSON file. 


=== The first example program
After starting the program the code editor always contains the code shown below: 

[source, javascript]
----
let holeRadius = Slider("Radius", 30 , 20 , 40);

let sphere     = Sphere(50);
let cylinderZ  =                     Cylinder(holeRadius, 200, true);
let cylinderY  = Rotate([0,1,0], 90, Cylinder(holeRadius, 200, true));
let cylinderX  = Rotate([1,0,0], 90, Cylinder(holeRadius, 200, true));

Translate([0, 0, 50], Difference(sphere, [cylinderX, cylinderY, cylinderZ]));

Translate([-25, 0, 40], Text3D("Hi!", 36, 0.15, 'Consolas'));
----

._Default code_
[#img-ccs-default]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/first-example.png[]

''''
This default code already introduces the user to several concepts of the code which is written in Javascript format: 

Comment lines:: Comment lines start with two forward slashes "//". Comment lines are not processed by the program but are used to clarify the code. 
Variable declarations:: Variables are declared with the keyword "let". Variables are names for values that can be used in the code. For example, if you want to model a box you will probably want to enter values for the width, depth and height of the box. In this case the width, depth and height are variables that can be passed to a function that contructs the box. It is not necessary to declare the type of data that is held in the variable. As shown in the example it is possible to declare a variable and assign a value to it in a single line. However, Javascript also allows to do this on two separate lines. Note that a variable name cannot be declared twice. 
Functions:: CascadeStudio offers some functions to decribe or construct 3D shapes. Functions are a set of actions that are performed in sequence to provide a result. A function call consists of the function name and a list of parameters between round brackets. The parameters are values that can be passed to the function to determine the result. For example, the function `Box(width, depth, height)` will construct a box with the values for width, depth and height that were earlier assigned to these variables. The first six comment lines already mention the most important functions that are offered. As we will see later, it is also possible to define new functions. 

A good starting point can be to apply small changes to the code and to see what happens. The first changes can even be performed using the 3D dialog. The slider labelled "Radius" can be used to adapt the radius of the cylinder that is central to the 3D shape. 

=== How to find your way in 3D space? 
To understand many of the commands in CascadeStudio it is useful to understand how a location in 3D space are defined. As almost all 3d modelling and CAD programs, CascadeStudio uses three coordinates to indicate a location. The 3-dimensional space is considered to be a large box. Each location in this box can be described by a movement parallel to the width, depth and height of this box. The width is called the x-axis, the depth is called the y-axis and the height is called the z-axis. If we combine the  distance to the origin along each of these axes in an array [x,y,z] these can be considered the coordinates of the location. 

This concept is illustrated in <<#coordinates>>. This image contains a box at the origin of space, a box translated 50 units along the x-axis, a cone translated 50 units along the z-axis and a sphere translated -50 units along the x-axis and 10 units along the z-axis. The image also illustrates how the size of the objects along x, y and z-axes is determined. 

CascadeStudio does not define what the units are. So each unit could represent a millimeter or a kilometer. When the shapes are exported to an STL or STEP file, the scale of the object has to be set in the 3D printing software or the CAD program. 

---
._How places are indicated with sequences of x, y and z coordinates__
[#coordinates]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/coordinates.png[nut,800]
--- 

As we will see later, for 2-dimensional sketches the coordinates can be shortened to only two values, namely [x,y]. Sketches in CascadeStudio are always created on the x-y plane and have to be rotated if shapes created from these sketches have to be oriented differently.  

=== Building a simple car
As a next step, let's try to construct a simple version of the car shape shown in the introduction (see <<img-ccs-fillets>>). To create this car in CascadeStudio you have to start the software, delete all the example code on the left side of the interface and enter the code shown below. Then press kbd:[F5] to interpret the code. The result will be shown on the right side in the 3D window. 

[source, javascript]
----
// Define car design variables
let car_length      = 50;
let car_width       = 20;
let overhang_front  = 8;
let overhang_rear   = 9;
let cabin_width     = 16;
let cabin_length    = 25; // 33 = station, 25=sedan, 15=pickup
let car_height      = 14;
let bonnet_height   = 8;
let bonnet_rounding = 4;
let bonnet_length   = 15;
let wheel_radius    = 5;
let tire_width      = 3;
let tire_protrude   = 1;
let rim_height      = 1;
let tire_compression= 1;
let road_clearance  = 3; 

// Derived properties
let wheel_base      = car_length - overhang_front - overhang_rear;
let cabin_narrowing = (car_width - cabin_width)/2;
let cabin_base      = road_clearance + bonnet_height
let cabin_height    = car_height-bonnet_height

// Draw car body and passenger cabin
let car_body        = Translate([0,0,road_clearance],Box(car_length,car_width,bonnet_height))
let car_cabin       = Translate([bonnet_length,cabin_narrowing,cabin_base-0.5],
                            Box(cabin_length, cabin_width, cabin_height))

// Sculpt the car body more aerodynamically
let car_body_rounded = FilletEdges(car_body,bonnet_rounding,[1,5])
let cabin_aero       = ChamferEdges(car_cabin, cabin_height-0.5 , [1,5])

// Round all edges
let cabin_rounded   = Offset(cabin_aero,1.5);
let car_shrunk = Offset(car_body_rounded,-1);
let car_rounded = Offset(car_shrunk,2); 

// Define wheels and wheel wells (Front/Rear - Left/Right)
let rim              = Rotate([1,0,0],-90, Translate(
                        [overhang_front,
                                   -(wheel_radius-tire_compression),
                                  -(tire_width - tire_protrude)]
                                  , Cylinder(wheel_radius-rim_height,tire_width,true)))
let wheel            = Rotate([1,0,0],-90, Translate( [overhang_front,
                                   -(wheel_radius-tire_compression),
                                  (0.5*tire_protrude)], 
                                  Cylinder(wheel_radius,tire_width,true)));
let wheel_FL         = Difference(wheel,[rim]);
let wheel_well_FL    = Offset(wheel,0.8,0.01,true)
let wheel_RL         = Translate([wheel_base,0,0], wheel_FL, true)
let wheel_well_RL    = Translate([wheel_base,0,0], wheel_well_FL, true)
let wheel_FR         = Rotate([0,0,1],180,Translate([-(2*overhang_front),-car_width ,0], wheel_FL, true))
let wheel_well_FR    = Translate([0,car_width-1,0], wheel_well_FL, true)
let wheel_RR         = Translate([wheel_base,0,0], wheel_FR, true)
let wheel_well_RR    = Translate([wheel_base,0,0], wheel_well_FR, true)

// Subtract the wheel wells from the car-body
Difference(car_rounded,[wheel_well_FL, 
                        wheel_well_RL, 
                        wheel_well_FR, 
                        wheel_well_RR])
----

The commands required to model this car will be explained in the next sections. 


== Three dimensional solid shapes
The easiest way to model in 3D is to start with basic solid shapes such as a box, sphere or cylinder. For example,  the car shown in the introduction (see <<#img-car-opencad>>) is build from only 2 boxes and 6 cylinders. CascadeStudio offers 5 basic shapes as shown in <<#shapes>>, namely boxes, spheres, cylinders, cones and 3D text. The next paragraphs will explain how these basic shapes can be defined. The next section will then explain how the shapes can be transformed, moved and rotated to construct more complex 3D shapes.  

---
._Basic 3D shapes offered by CascadeStudio_
[#shapes]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/shapes.png[shapes,600]
--- 

=== Box
The function Box creates a rectangular solid prism with the dimensions x,y,z. The fourth parameter, which is a boolean, indicates whether the box is placed with its center at the position [0,0,0] or with its first corner. 

[source, javascript]
----
// Box(x,y,z,centered?)
let exampleBox      = Box(20,30,15, false)
----

=== Sphere
Creates a sphere of specified radius

[source, javascript]
----
// Sphere(radius)
let exampleSphere   = Sphere(10) 
----


=== Cylinder
Creates a Cylinder with a radius and height. The arguments are radius, height, centered?. The latter is a boolean indicating whether the shape is centered on the workplane, making half of the height appear above the workplane and half below it, or whether the cylinder starts at the workplane and extends the full height into the normal direction. Omitting the last parameter defaults to "not centered".

[source, javascript]
----
// Cylinder(radius, height, centered?)
let exampleCylinder = Cylinder(10,20,false)
----

=== Cone
Creates a revolved trapezoid with differing top and bottom radii. The arguments to this function are radius1, radius2 and height.

[source, javascript]
----
// Cone(radius1, radius2, height)
let exampleCone     = Cone(10,2,20)
----
   
=== Text3D
Creates 3D Text from a TrueType font. The first parameter is the text string in parentheses, the second parameter defines the size of the characters. The third parameter then defines the extrusion depth of the characters, so how 'thick' the characters are. The last parameter in single parentheses defines the font of the characters. 

[source, javascript]
----
// Text3D("textstring", size, thickness%, 'font')  
let exampleText     = Text3D("Text", 15, 0.2,'Roboto')
----

== Changing three dimensional shapes
The commands in this section can be used to change the shapes that were created. These apply to the shapes created using the functions described in the previous section or using the more complex functions that will be discussed in the next sections.  

=== Translate

The Translate function can be used on shapes but also faces and wires to shift the items along the x,y and z axis. The amount of the displacement is defined in an vector [x,y,z]. The boolean "keepOriginal" indicates whether a copy is displaced (keepOriginal = true) or whether the original shape is displaced. The latter, i.e. the original shape is displaced, is the default setting and may be omitted in the function call. 

[source, javascript]
----
// Translate(offset, shapes, keepOriginal?)
let nameDisplacedItem = Translate([0,0,30],originalShape,false);
----

If the shape is not assigned to a new variable name, the orinal variable name can be used to reference the shape for further manipulation. 

=== Rotate

The Rotate function is similar to the Translate function. Instead of a displacement a rotation around an axis is defined. The rotation is defined by specifying the axis of ration first, using a vector notation [x,y,z]. As an example, the x-axis is defined as [1,0,0], the z-axis as [0,0,1]. The second parameter defines the rotation in degrees. The boolean "keepOriginal" works identical to the way described for the Translate function. 

[source, javascript]
----
// Rotate(axis, degrees, shapes, keepOriginal?)
Rotate([0,1,0], -90, boxShape, true);
----

The rotation is clockwise when looking into the positive direction of an axis. So for example, the rotation of 90 degrees around the y-axis [0,1,0] will turn your object to the right through the ground plane. The rotation is always performed with reference to the global origin. So if your object is not centered at the global origin, the object will not only be rotated but also displaced (see <<#rotate-origin>>). 

---
._Rotation is always performed with reference to the global origin_
[#rotate-origin] 
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/rotate_origin.png[rotation,600]
---

=== Scale
The third transformation function is Scale. The first parameter of the function is the uniform scale that is applied to the shape. The second parameter is the shape that is scaled, the third is again a boolean indicator (true/false) that determines if the original shape is retained or deleted. Note that CascadeStudio does not support a non-uniform scaling of objects. The OpenCascade kernel does support more complex transformations, but it might be argued that non-uniform scaling is not a desirable function as it changes the nature of the shapes that were created by the preceding code. Note that many of the applications that are available to construct a real 3D part do support non-uniform scaling. So if this non-uniform scaling is required to compensate for an inaccuracy of the CNC-machine or 3D printer, this can be achieved after the export of the shape to an STL or STEP format. 

[source, javascript]
----
//Scale(scale, shapes, keepOriginal?)
let smallBox = Scale(0.2, boxShape, true);
----


=== Transform
There is a more or less experimental function called Transform that combines the three previous functions Translate, Rotate and Scale into a single function. The function can be called using the full code: 

[source, javascript]
----
// Transform(translation, rotation, scale, shapes)
let largeBox = Transform([0, 0, 30], [[1, 00, 0], 30], 2.00, displacedSmallBox); 
----

Calling the function Transform without the full set of arguments triggers the display of an interactive "gizmo" that allows to change the values of the transformation using click and drag of sliders. Note that CascadeStudio automatically adapts the values shown in the code to the values indicated with the gizmo. However, the level of control with the gizmo is limited as the interaction with the gizmo lacks a direct feedback to the user. Using code - by applying separate instructions for Translate, Rotate and Scale - delivers more repeatable and consistent results. 

If the gizmo is visible, the following keyboard shortcuts can be used: 

[cols="1,1"]
|===
| kbd:[W]		| Translate
| kbd:[E]		| Rotate
| kbd:[R]		| Scale
| kbd:[X] 	| World or Local origin
|===

[NOTE]
====
In the latest version the gizmo no longer seems to work
====


=== Offset
Dilates or contracts a shape by the specified distance. This is similar to the socalled minkowski sum with a sphere (known from the OpenSCAD application) which rolls a sphere around the base shape. 

[source, javascript]
----
// Offset(shape, offsetDistance, tolerance, keepShape?)   
Offset(Text3D("H", 36, 0.15, "Roboto"), 2.25*t)
----

As a positive offset of a sharp corner results in a rounded shape, the offset function can be used to create a rounded cube/box from a normal cube/box. This is achieved by first contracting the shape with the required rounding radius - which preserves the original shape - and then applying the positive offset with the same distance. The steps are demonstrated in the function shown below.

[source, javascript]
----
function RoundAll(shape,fillet)
{
    let shrunk_version = Offset(shape,-fillet)
    let grown_version = Offset(shrunk_version, fillet)
    return grown_version
}
----

---
._Effect of positive and negative offset on shapes_
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/offset.png[offset,600]
---

As we will see later, the offset function can also be used to create thin-walled shapes (see <<#Difference>>). 


=== FilletEdges
The function `FilletEdges` can be used to bevel individual edges on a shape. 

[source, javascript]
----
// FilletEdges(shape, radius, edgeList, keepOriginal?)
FilletEdges (Cylinder(10, 20), 2, [0,2], false)
----    

The first parameter of the function identifies the shape that contains the edges, the second parameter sets the radius of the bevel or fillet. The third parameter contains the array of edges that should be rounded, i.e. a list of edges between square brackets. The edge indices can be found by hovering the mouse over the edge. The fourth parameter is a boolean indicating whether the original shape should be retained or deleted.  

---
._Finding the edge index by hovering the mouse over the edge_
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/edge_index.png[edgeindex,500]
---

Note that it is sufficient to list one of the edges in a loop or chain of edges for filleting. However, this behaviour is not always predictable. It seems that if there are multiple loops of which an edge can be a member, only this single edge is filleted. If there is already another fillet, it seems easier to select just a single edge to fillet a complete loop. Just try an edge and determine the result. Note that you always have to revert back to the original shape if you want to add another edge to the list, as the edge numbering is adapted after the filleting operation. 

    
=== ChamferEdges
The function ChamferEdges resembles the function FilletEdges but applies a 45-degree cut to an array of edges on a shape. The parameters are almost identical to that of FilletEdges: the first parameter is the shape, the second parameter the size of the chamfer, the third parameter the list of edges and the fourth parameter the indication whether the original shape should be kept. The default value for the last parameter is false and may therefore be omitted.  
    
[source, javascript]
----    
// ChamferEdges(shape, distance, edgeList, keepOriginal?)
ChamferEdges(Cylinder(10, 20), 4*t, [0,2])
----

The function ChamferEdges can only add a symmetric chamfer. An adapted version to apply an asymmetric chamfer is provided in <<#UnevenChamferEdges>>.  

== Combining 3D solid shapes
A really powerfull way to create new shapes is combining basic shapes using socalled boolean operations. It is like adding and subtracting shapes in 3D. 

=== What are boolean functions? 
Boolean functions are functions that work on boolean variables that have only two values such as `true` and `false` or 1 and 0. Some of the basic functions are then: 

----
AND:: If A AND B are both true, the result is true, in all other cases the result is false;
NAND:: If A AND B are not both true, the result is true, else the result is false; 
OR: If at least A OR B are true, the result is true, if both are false the result is false;
XOR:: If either A OR B are true, the result is true, of they are both true or both false, the result is false; 
NOT:: The result is always the opposite of the input. 
----

=== Boolean functions in 3D 
The boolean operations in 3D modelling act very similar. Instead of inputs having the value true or false, a point in space may be considered to be inside an object or outside. If we then consider two objects we can have the following operations: 

--
Union:: If a point is part of either object A OR object B, it is part of the resulting object. It is as if the two objects are fused together into a single object. If the operation is performed correctly, the socalled inner boundaries inside the new shape are no longer present and a larger new solid is created. Some programs call this operation 'Fuse'. 

Intersection:: If a point is both part of object A and object B, it is considered to be part of the resulting object. So only the overlapping parts of the two objects remain and form a new shape. An alternative name for this operation is 'Common'. 

Difference:: The Difference function represents a subtraction of object B from object A. For this operator the order of the parameters matters, as the second objects are subtracted from the first object. An alternative name for this operation is 'Cut'.   
--

<<#nut>> shows how the shape of a nut can be created by combining an number of boxes, cylinders and cones. 

---
._Using boolean operations to create a nut from basic 3D shapes_
[#nut]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/nut_flow.png[nut,800]
--- 

Although the definition of boolean operations seems very straight forward, the actual calculation of the resulting shape is quite complex. As it is not possible to perform the calculation of the value for each infinitely small point in space, the software has to calculate the boundaries between two objects and define the division line between the two objects. This works best if there is a clear division line between the objects so that in case of small rounding errors in the calculation or the performance of the calculation with a reasonable step size the result of the calculation is still clear. Two conditions to consider are therefore whether an object is *manifold* and whether faces of the objects used for the calculation are *not parallel touching*. 

[WARNING]
====
The input shapes for boolean operations should be manifold, i.e. completely closed. If this is not the case, the software can not determine whether a point in space is inside or outside of the object. 
====

[WARNING]
====
If faces of the two objects are coplanar, touching or nearly coincident, the software can have trouble determining the demarcation between the two objects. In that case the calculation might fail or give incorrect results. If possible try to avoid coplanar faces in boolean operations, especially in Difference/Cut operations. 
====

In the example shown in <<#nut>> the cylinder used to cut a hole through the body of the nut is made much longer than the thickness of the nut so that there are no coplanar faces. 

The definition in CascadeStudio of the boolean functions and its parameters are specified in more detail in the ext paragraphs. 

=== Union
Union allows to combine shapes into a single (solid) shape. The function call looks like this: 

[source, javascript]
----
Union([objectsToJoin], keepObjects, fuzzValue, keepEdges)
----

The first parameter combines all the objects to join into a single list or array, enclosed in square brackets. The second parameter is a boolean (true/false) that indicates if the original objects should be kept or may be removed. The fuzzValue parameter determines the distance that is used by the calculation to determine if a point is part of the object or not. The default value (that is used when the fuzzValue is not defined) is 0.1. Increasing or lowering the fuzzValue might help if the calculation fails due to coplanar surface or other unfavourable geometries. 

The following code snippet shows how three boxes can be combined into a hexagon shape. 

[source, javascript]
----
let box1 = Box(g/2,f,1.1*h,true)
let box2 = Rotate([0,0,1],60,Box(g/2,f,1.1*h,true))
let box3 = Rotate([0,0,1],120,Box(g/2,f,1.1*h,true))
let hexagon = Union([box1, box2, box3], false, 0.01, false);
----

Strangely enough it is possible to combine shapes that are not overlapping into a single shape. In that case it seems as if nothing is changed after performing the operation, but the resulting shape can be used in other boolean operations as a single object. 

=== Difference
The Difference function can be used to subtract parts of a shape. The first parameter contains the body that functions as the main body to subtract parts from. The second parameter contains a list of all the shapes that should be subtracted from the main body. Parts in space that are covered by both the main body as the subtracting parts are removed from the main body. In other words, the subtracting shapes can be used as a kind of punch. The third parameter can be set to 'true if the subtracting parts should be kept in the scene. Normally this is not the case (as else the result of the Difference function is not visible), so the default value of this parameter is 'false'. 
The fourth parameter contains the 'fuzzy value' that governs the tolerance of the boolean calculation. Normally this value can be left at the default value, but if your boolean function fails it is an option to adjust this value to attempt if the issue can be solved. Finally, the fifth parameter indicates whether the edges that were present before punching the holes should be kept. Normally you would want these extra edges to be removed. 


[source, javascript]
----
// Difference(mainBody, objectsToSubtract, keepObjects, fuzzValue, keepEdges)
let cutterHole = Cylinder(d/2,h*3,true)
let nut = Difference(nutShape, [cutterHole])
----

The Difference function can be used in combination with the Offset function to create thin-walled versions of solids. This is achieved by applying a negative offset with the value of the wall thickness to an object and then subtracting this new shape from the original shape. Note that unless another 'cut' is made into this shape it is not visible from the outside that the new shape is hollow. 

[source, javascript]
----
function ThinWall(shape,thickness)
{
    let shape_original = shape;
    let shrunk = Offset(shape, -thickness);
    let hollow = Difference(shape_original,[shrunk],false);
    return hollow;
}   
----


=== Intersection
The function Intersection combines different shapes and retains those parts that are intersecting between these shapes. The function is therefore also referred to as the 'Common' function. The shapes that are intersected are listed in the first parameter to the function, enclosed in square brackets. The second parameter is a boolean that indicates if the original shapes should remain in the scene. The default value for this parameter is false. The third value is the fuzzy factor described earlier for the other boolean functions. The last parameter is a boolean indicating whether the edges of the original shapes should be retained. 

[source, javascript]
----
// Intersection(objectsToIntersect, keepObjects, fuzzValue, keepEdges)
let nutShape = Intersection([nutBodyBase,hexagon],false, 0.01,false)
---- 

=== RemoveInternalEdges
The function RemoveInternalEdges can be used to remove internal edges in shapes that were created using boolean functions. Normally this function is not required as the boolean functions described above already remove the internal edges. The first parameter is the shape that should be cleaned, the second parameter indicates whether the original shape should be retained in the scene. 

[source, javascript]
----
// RemoveInternalEdges(shape, keepShape?)
let cleanPart = RemoveInternalEdges(part)
----

== Creating faces or wires



=== Sketch
Some of the modelling approaches involve drawing a 2-dimensional sketch first and than creating a wire or solid from this sketch by extruding, revolving or lofting the 2D shapes into a 3-dimensional shape.

---
._Using a 2-dimensional sketch as basis to create 3-dimensional shapes_
[#img-ccs-sketch]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/sketch_to_shape.png[1000]
---

==== new Sketch
A new sketch is started with the command

[source, javascript]
----
let mysketch = new Sketch([xvalue,yvalue])

let face = new Sketch([-10*t,-8*t]).Fillet(2*t).
               LineTo([ 10*t,-8*t]).Fillet(2*t).
               LineTo([  0*t, 8*t]).Fillet(2*t).
               End(true).Face();
----

The Sketch function is unique for all functions, as that it needs to be called with the "new" keyword prepended.
The sketch can be expanded by adding lines, arcs, cirles, splines and fillets. 
	
==== .LineTo

[source, javascript]
----
 mysketch.LineTo([xvalue2,yvalue2])
----
==== .Fillet

[source, javascript]
----
 mysketch.LineTo([xvalue2,yvalue2]).Fillet(filletradius)
----

==== this.End
The command .End finishes the sketch. Two booleans can be added as parameter. If the first boolean is true, the sketch will be closed to the first point of the sketch. This relieves the user from drawing the last line back to the starting point. The second parameter determines whether the direction of the sketch is reversed (true) or not (false). The direction of the sketch determines the direction of the normal and therefore the direction of the face. Note that the face is only visible when looking against the normal of the face. 

[source, javascript]
----
// this.End(closed, reversed)
mysketch.LineTo([xvalue2,yvalue2]).End(true)
----

==== this.Face
The command .Face() makes a face out of the closed contour. The boolean optional parameter indicates whether the face is reversed (true) or not (false). The default value is false. 

[source, javascript]
----
// this.Face(reversed?)
let face = new Sketch([-10*t,-8*t]).Fillet(2*t).
               LineTo([ 10*t,-8*t]).Fillet(2*t).
               LineTo([  0*t, 8*t]).Fillet(2*t).
               End(true).Face(true);
----

==== this.Wire
The command .Wire() creates a wire (a set of connected points in 2D space). Wires can be used to Loft a solid or to extrude a shell.

[source, javascript]
----
// this.Wire(reversed?)
mysketch.LineTo([xvalue2,yvalue2]).End(true).Wire()
----

Just as with a face, a boolean "true" can be added to Wire to reverse the direction of the wire.


==== this.ArcTo
With ArcTo it is possible to define an from the last point to the end point and adding a point on the arc.

[source, javascript]
----
// sketch with arc 
// this.ArcTo(pointOnArc, arcEnd)
let arc_test = new Sketch([0,0])
.LineTo([10,0])
.ArcTo([15,5],[10,10])
.LineTo([0,10]).Fillet(2)
.End(true).Fillet(2).Face();

arc_test_displaced = Translate([0,-15,0], arc_test);
Extrude(arc_test_displaced,[0,0,30]);

// same shape created with two fillets
// note the additional edge
let fillet_test = new Sketch([0,0])
.LineTo([15,0]).Fillet(5)
.LineTo([15,10]).Fillet(5)
.LineTo([0,10]).Fillet(2)
.LineTo([0,0]).Fillet(2)
.End(false).Face();
Extrude(fillet_test,[0,0,20])
 
// It is not possible to combine the end of an arc or fillet
// with a fillet, but two matching fillets work 
let fillet_fillet = new Sketch([0,0])
.LineTo([15,0]).Fillet(3)
.LineTo([15,3]).Fillet(2)
.LineTo([15,5]).Fillet(2)
.LineTo([0,5]).Fillet(2)
.LineTo([0,0]).Fillet(2)
.End(false).Face();

Translate([0,15,0],Extrude(fillet_fillet,[0,0,10]))
----

._Example of a sketch with ArcTo command_
[#img-ccs-arcto]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/ccs-arcto.png[]

Note that in the example above, there two different approaches to create a 180 degree arc. The first one uses the function ArcTo, the second one uses two fillets. This results in an additional edge in the middle of the arc, but the cross section of these shapes is identical. Another thing to note is that a fillet at the end of an arc or another fillet does not work. If you want to achieve this you would have to construct an arc up to the point where the fillets start, and add a straight corner after that which can be filleted. 

==== this.BezierTo
Constructs an order-N Bezier Curve where the first N-1 points are control points and the last point is the endpoint of the curve. 

[source, javascript]
----
// this.BezierTo(bezierControlPoints)
----

==== this.BSplineTo
Constructs a BSpline (Basic Spline) from the previous point through this set of points. The behaviour of a Bspline can be a bit more unpredictable than the behaviour of a Bezier curve. <<#bezier>> shows how an ellipse can be approximated using a Bezier curve. The location of the control points is marked with the cylinders. Note that if we use the same control points for a BSpline, the curve becomes quite different, possibly because the BSpline tries to pass through the control points.     

[source, javascript]
----
// this.BSplineTo(bsplinePoints)
----

// [caption="Figure {counter:figure}: ", reftext="Fig. {figure}"]
// .Example image
// [#img_01]
// image::01.png[, 80%,align="center"]

---
._Comparison of a true ellipse and an approximation by using a Bezier and a BSpline_
[#bezier]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/bezier.png[width=700]
---


=== Polygon
With the Polygon command it is possible to shorten the definition of a sketch. The Polygon is defined by a number of three dimensional point in space, defined as [x,y,z] coordinates.

[source, javascript]
----
// Polygon(points, wire?)
Polygon([[-25, -15, 0], [25, -15, 0], [0, 35, 0]], true)
---- 

The boolean indicates whether the Polygon describes a Wire (true) or a Face (false).

=== Circle
The circle command can be used to draw a 2-dimensional circle with a specified radius. The arguments to this function are radius, wire?. The wire? parameter indicates whether the circle should be shown and handled as a face or as a wire.

[source, javascript]
----
// Circle(radius, wire)
----


=== BSpline
The Bspline function draws a spline through the points that are entered as a list. The arguments are a list of points, followed by a boolean the indicates whether the wire should be closed (true) or open (other).As can be seen in the example below, the BSpline can also be used as a rail to construct a pipe by sweeping a face along this rail. The Pipe command will be explained below.

[source, javascript]
----
// BSpline(inPoints, closed)
Pipe(face, BSpline([[0,0,0],[0,0,10],[13,-10,30]], false))
---- 


== Creating shapes from faces or wires
Most of the following functions work both on faces and on wires. Lofting and the RotatedExtrude require wires. A wire can be retrieved from a face using the "GetWire" function (see below). 

=== Extrude
Extrudes a face along a vector direction

[source, javascript]
----
// Extrude(face, direction, keepFace)
Extrude(face, [20*(1-t), 0, 20]),
----


=== RotatedExtrude
Extrudes a wire vertically with a specified height and twist. Note the difference from the standard extrude, in that this function requires a wire instead of a face. This can be accomplished by using the `.Wire()` method for a sketch instead of the `Face()`. Another thing to point out is that the rotation is performed relative to the [0,0] location of the vertical axis. Moreover, the extrusion is always vertical - so along the z-axis or [0,0,1] - and not along the normal of a wire. The boolean keepwire indicates whether the wire should be kept or may be removed.  

[source, javascript]
---- 
RotatedExtrude(wire, height, rotation[deg], keepWire?)
RotatedExtrude(wire, height, degrees, false)
---- 

---
._Difference of RotatedExtrude depending on position of wire relative to origin_
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/rotated_extrude.png[width=500]
---

---
._Difference of RotatedExtrude exagerated by using a larger twist_
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/rotated_extrude2.png[width=500]
---


=== Pipe
Sweeps a face along a Wire

[source, javascript]
---- 
// Pipe(shape, wirePath, keepInputs)
Pipe(face, BSpline([[0,0,0],[0,0,10],[13,-10,30]], false)),
---- 


=== Revolve
Revolves the shape listed as the first parameter the number of "degrees" listed in the second parameter about "axis" (a 3-component array) listed as the third parameter. These parameters may be followed by two boolean values, the first of which indicates whether the revolved shape should be kept in the scene and the second indicates whether the function should create a copy. Edges form faces, Wires form shells, Faces form solids. 

[source, javascript]
---- 
// Revolve(shape, degrees, [axis], keepShape?, copy?)
Rotate([1,0,0], 90, Revolve(Translate([10*t,8*t,0], GetWire(face)), -60, [0, 1, 0])),
----

<<#revolve>> shows some interesting properties of the revolve function. The inner shape is created from a wire, the outer shape is created from a face. Both are cut-open using the boolean Difference function with a large box. It is clearly visible that the inner shape is a shell that is infinitely thin. Differently from faces the shell is visible from both sides. The outer shape is a solid. Note also that although the function specifies that the revolve should only be 90 degrees, both form a complete circle. 

---
._Different results of the revolve function_ 
[#revolve]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/revolve2.png[revolve,500]
---


=== Loft
A loft is a modelling function that takes a number of planar wire-sections and interpolates between those. The wires act as the ribs of a construction and the lofting function is like stretching a shell around these ribs, just like the planking of a boat. The function Loft builds a solid through the sections defined by an array of 2 or more closed wires.

[source,javascript]
----
// Loft(wires, keepWires)	
Loft([GetWire(face), Translate([0,0,20], Circle(8, true))]),
----



=== GetWire
As some of the functions above require a wire, it may be useful to retrieve a wire from a face. This can be achieved with the function GetWire. The first parameter indicates the shape that contains a face, the second parameter contains the index of the required face and the boolean indicates whether the original shape should be kept (true) or deleted (false). The following code snippet shows an example for creating a rectangle by using the bottom face of a box (with face index 4) to retrieve the wire of a rectangle. Note that it is necessary to translate the wire to the correct location before using it as input to another function. 
 
[source, javascript] 
----
// GetWire(shape, faceIndex, keepOriginal)
let width = 25;
let length = 50;
let height = 10;

let box1 = Box(width,length,height,true);
let wire4 = Translate([0,0,height/2],GetWire(box1,4,false))
RotatedExtrude(wire4,50,90 )
----


== Saving and exporting 

=== Saving your model




=== Exporting 3D models

General: the MeshRes in the dialog is linked to the internal variable maxDeviation which is in fact a much better name. The lower this value, the more accurate the model will be represented in the 3D window and the more accurate the export file will be. This comes at a cost however. A more detailed model will take more time to render in the 3D view and result in larger meshes in the exported files.                          

==== STEP export

==== STL export


==== OBJ export




== Create new functions

=== What are functions? 

New functions can be declared according to the Javascript syntax. This starts with the keyword "function", then a function name (often with a capital first character) and then two rounded brackets around a list of parameters. The function performs some action using the parameters as input and can return values, wires, shapes et cetera. 



=== Creating new functions using CascadeStudio functionality







=== Create new functions using OpenCascade kernel

==== How to call functionality from OpenCascade kernel
In the example below the function Sphere requires a definition of the radius and returns the shape of a sphere around the point [0,0,0].  

[source, javascript]
----
 function Sphere(radius) {
   let curSphere = CacheOp(arguments, () => {
    // Construct a Sphere Primitive
     let spherePlane = new oc.gp_Ax2(new oc.gp_Pnt(0, 0, 0), oc.gp.prototype.DZ());
     return new oc.BRepPrimAPI_MakeSphere(spherePlane, radius).Shape();
   });

   sceneShapes.push(curSphere);
   return curSphere;
  }
---- 



==== UnevenChamferEdges

[source,javascript]
----
function UnevenChamferEdges(shape, dist1, dist2, edgeList, face, keepOriginal) { 
  let curChamfer = CacheOp(arguments, () => {
    let mkChamfer = new oc.BRepFilletAPI_MakeChamfer(shape);
    let foundEdges = 0;
    ForEachEdge(shape, (index, edge) => {
      if (edgeList.includes(index)) { mkChamfer.Add(dist1, dist2, edge,face); foundEdges++; }
    });
    if (foundEdges == 0) {
      console.error("Chamfer Edges Not Found!  Make sure you are looking at the object _before_ the Chamfer is applied!");
      return new oc.TopoDS_Solid(shape);
    }
    return new oc.TopoDS_Solid(mkChamfer.Shape());
  });
  sceneShapes.push(curChamfer);
  if (!keepOriginal) { sceneShapes = Remove(sceneShapes, shape); }
  return curChamfer;
}


box1 = Box(20,20,20)
UnevenChamferEdges(box1,1,3,[1,9,5,11],5, false)
----


=== Possible extensions to sketch functions
The software CadQuery (https://github.com/CadQuery/cadquery) that is also based on the OpenCascade kernel offers more sketch commands than CascadeStudio. Some of these functions can be built from the existing CascadeStudio functions, some others would require more work by adapting the calls to the OpenCascade library. The following list of functions of CadQuery was taken from https://cadquery.readthedocs.io/en/latest/apireference.html. 

[cols="1,1, 1"]
|===
|CascadeStudio  | CadQuery 			| Extensions 
|		| .line				| Dxy()
|.LineTo	|.lineTo 			| .LineTo()
|		|.vLine				| Dy()
|		|.vLineTo			| - 
|		|.hLine				| Dx()
|		|.hLineTo			| 
|		|.polarLine			| Polar(), PolarX(), PolarY()
|		|.PolarLineTo			| -
|		|.moveTo			| -
|		|.move				| -	
| .ArcTo	| .threePointArc	   	| -
|		|.sagittaArc			| SagArc()
|		|.radiusArc			| RadiusArc()
|		|.tangenArcPoint		| 
| -             | .mirrorY .mirrorX		| MirrorY(), MirrorX()
| - 		| .rect				| Rect(), FilletRect()
| .Circle	| .circle			| -
| - 		| .ellipse .ellipseArc		| Ellipse()
| Polygon	| .polyline			| RegularPolygon()
| .End		| .close			| 
| -		| .rarray			|
| - 		| .polarArray			|
| -		| .slot2D			|
| - 		| .offset2D			|
|===		


==== Dx, Dy, Dxy
The functions Dx, Dy and Dxy can be used to determine the coordinates of the next point from the difference in the x-coordinate (horizontal distance if looking at the x-y plane from the top), the difference in the y-coordinate (vertical distance) and the difference in both x and y coordinate. The concept of these functions is to determine the absolute coordinates of the points along the sketch using relative distances from one point to the next. The absolute coordinates can then be used together with the standard sketch functions provided by CascadeStudio. 

---
._Definition of Dx, Dy, Dxy_
[#dxy]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/dxy.png[dxy,500]
---


[source, javascript]
----
function Dxy(currentPoint,dx,dy)
{ 
    let newPoint = []; 
    newPoint[0]  = currentPoint[0] + dx;
    newPoint[1]  = currentPoint[1] + dy; 
    return newPoint
}

function Dx(currentPoint,dx)
{ 
    let newPoint = []; 
    newPoint[0]  = currentPoint[0] + dx;
    newPoint[1]  = currentPoint[1] ; 
    return newPoint
}

function Dy(currentPoint,dy)
{ 
    let newPoint = []; 
    newPoint[0]  = currentPoint[0];
    newPoint[1]  = currentPoint[1] + dy; 
    return newPoint
}
----

==== Polar, PolarX, PolarY

The function Polar calculates the position of a point based on the distance and the angle to the previous point. The angle is specified as degrees from the x-axis, measured counter-clockwise. The parameters are the point that is used as reference to calculate the new point, the distance between the current and the new point and the angle in degrees. In the function PolarX the distance represents the difference in the x-coordinate (so the horizontal distance), in the function PolarY the distance represents the difference in the y-coordinate (so the vertical distance). 

---
._Definition of Polar, PolarX and PolarY_
[#polar]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/polar.png[dxy,500]
---




[source, javascript]
----
function Polar(currentPoint,distance,angleDegToX)
{ 
    let newPoint = []; 
    angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + distance * Math.cos(angleRad);
    newPoint[1]  = currentPoint[1] + distance * Math.sin(angleRad); 
    return newPoint
}

function PolarX(currentPoint,xdistance,angleDegToX)
{ 
    let newPoint = []; 
    let angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + xdistance;
    newPoint[1]  = currentPoint[1] + xdistance * Math.tan(angleRad); 
    return newPoint
}

function PolarY(currentPoint,ydistance,angleDegToX)
{ 
    let newPoint = []; 
    let angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + ydistance/Math.tan(angleRad);
    newPoint[1]  = currentPoint[1] + ydistance; 
    return newPoint
}
----


==== RadiusArc
The function RadiusArc can be used to calculate a third point to feed to the function .ArcTo, using the definition of the starting point, the end point and the radius of the curve between these two points. The last parameter is a boolean indicating whether the curve should be followed clockwise or anti-clockwise from starting point to endpoint. If the curve should be followed clockwise from  starting point to endpoint the boolean should be set to `true`, otherwise it should be set to `false`. 

---
._Definition of RadiusArc_
[#radiusarc]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/radiusarc.png[dxy,500]
---

[source, javascript]
----
function RadiusArc(currentPoint,endPoint,radius, clockwise)
{
    let midPoint = [];
    let dx = endPoint[0] - currentPoint[0];
    let dy = endPoint[1] - currentPoint[1];
    let dist = Math.sqrt(Math.pow(dx,2)+Math.pow(dy,2));
    let alpha = Math.asin(dy/dist);
    let beta  = Math.asin((dist/2)/radius);
    let sag = radius - (Math.cos(beta) * radius)
    if (dx<0){clockwise = !clockwise}
    if (clockwise == true)
    {
    midPoint[0] = currentPoint[0] + dx/2 - Math.sin(alpha)*sag;
    midPoint[1] = currentPoint[1] + dy/2 + Math.cos(alpha)*sag; 
    }
    else
    {
    midPoint[0] = currentPoint[0] + dx/2 + Math.sin(alpha)*sag;
    midPoint[1] = currentPoint[1] + dy/2 - Math.cos(alpha)*sag;
    }
    return midPoint
}
----


==== SagArc
The function SagArc is an adapted version to define the curvature of an arc between two points. The idea is to connect these two points with a straight line and then define the maximum distance between the intended curve and the straight line, the socalled 'sag'. The parameters of the function are the starting point, the end point, the maximum distance between the curve and the straight line and finally the direction of the curvature. If the curve should be followed clockwise from  starting point to endpoint the boolean should be set to `true`, otherwise it should be set to `false`. 

---
._Definition of SagArc_
[#sagarc]
image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/sagarc.png[dxy,500]
---

[source, javascript]
----
function SagArc(currentPoint,endPoint,sag,clockwise)
{
    let midPoint = [];
    let dx = endPoint[0] - currentPoint[0];
    let dy = endPoint[1] - currentPoint[1];
    let dist = Math.sqrt(Math.pow(dx,2)+Math.pow(dy,2));
    let alpha = Math.asin(dy/dist);
    if (dx<0){clockwise = !clockwise}
    if (clockwise == true)
    {
    midPoint[0] = currentPoint[0] + dx/2 - Math.sin(alpha)*sag;
    midPoint[1] = currentPoint[1] + dy/2 + Math.cos(alpha)*sag; 
    }
    else
    {
    midPoint[0] = currentPoint[0] + dx/2 + Math.sin(alpha)*sag;
    midPoint[1] = currentPoint[1] + dy/2 - Math.cos(alpha)*sag;
    }
    return midPoint
}
----

==== MirrorX, MirrorY
The functions MirrorX and MirrorY calculate the position of a point that is mirrored from a reference point in either the x-axis or the y-axis. The function has two parameters, namely the point that is mirrored and the position of the horizontal or vertical line that is used as the mirror-plane. So for example, in MirrorX the second parameter represents the y-coordinate of the displaced y-axis that is used as the mirror-line. If the second parameter is set a 0, respectively the the x-axis or the y-axis are used as the mirror-line. 

[source, javascript]
----
function MirrorX(currentPoint, yvalue)
    {
        let mirrorPoint = [];    
        mirrorPoint[0] = currentPoint[0];
        mirrorPoint[1] = yvalue - (currentPoint[1]-yvalue);
        return mirrorPoint
    }

function MirrorY(currentPoint, xvalue)
    {
        let mirrorPoint = [];    
        mirrorPoint[0] = xvalue - (currentPoint[0]-xvalue);
        mirrorPoint[1] = currentPoint[1];
        return mirrorPoint
    }
----

==== Example usage of sketching extensions
If you want to use the new functions as defined above you can enter them at the beginning of your code for each new part. It is also possible to make a separate file that only contains the definition of the new functions, place this in a directory where the CascadeStudio code is placed and import this file with the following command: 

[source, javascript]
----
importScripts('../nsketch.js') 
----

In the example the file is located in the directory `js` that is located directly below the directory that contains the `index.html` that is used to start CascadeStudio with your own live server. 


The following code shows an example how the functions defined in the previous sections can be used to construct a complex shape without calculating all absolute coordinates required to produce the sketch. 

[source, javascript]
----
let p0 = [0,0]
let p1 = Dx(p0, 10); 
let p3 = Dy(p1, 10); 
let p2 = SagArc(p1,p3,4,true)
let p4 = Polar(p3,10,135)
let p5 = Dx(p4,-10);
let p7 = Dy(p5,-10)
let p6 = RadiusArc(p5,p7,7,false)
let p8 = MirrorY(p6,0)
console.log(p6)
console.log(p8)

let test = new Sketch(p0)
.LineTo(p1)
.ArcTo(p2,p3)
.LineTo(p4)
.LineTo(p5)
.ArcTo(p6,p7)
.End(true).Face()
Extrude(test,[0,0,20])
----

==== Rect
The function Rect draws a rectangular face with straight edges. The parameters are width (x) and depth (y0. The third parameter is a boolean that indicates whether the shape should be centered. The default is that the shape is centered. 

[source, javascript]
----
function Rect(x,y,center) {
                    let p0;
                    let p1;
                    let p2;
                    let p3;
                    if (center == false) 
                    {
                        p0 = [0,0];
                        p1 = [x,0];
                        p2 = [x,y];
                        p3 = [0,y];
                    }
                    else
                    {
                        p0 = [-0.5*x,-0.5*y];
                        p1 = [0.5*x, -0.5*y];
                        p2 = [0.5*x,  0.5*y];
                        p3 = [-0.5*x, 0.5*y];
                    }        
                    return new Sketch(p0)
                   .LineTo(p1)
                   .LineTo(p2)
                   .LineTo(p3)
                   .End(true)
                   .Face();
                 }
----


==== FilletRect 
The function FilletRect draws a rectangle with fillets in each corner. The parameters are width, depth, fillet radius and a boolean indicating whether the shape should be centered around the origin or be started at the origin. The default is that the shape is centered. 

[source, javascript]
----
function FilletRect(x,y,f,center) {
                    let p0;
                    let p1;
                    let p2;
                    let p3;
                    if (center == false) 
                    {
                        p0 = [0,0];
                        p1 = [x,0];
                        p2 = [x,y];
                        p3 = [0,y];
                    }
                    else
                    {
                        p0 = [-0.5*x,-0.5*y];
                        p1 = [0.5*x, -0.5*y];
                        p2 = [0.5*x,  0.5*y];
                        p3 = [-0.5*x, 0.5*y];
                    }        
                    return new Sketch(p0)
                   .LineTo(p1).Fillet(f)
                   .LineTo(p2).Fillet(f)
                   .LineTo(p3).Fillet(f)
                   .End(true).Fillet(f)
                   .Face();
                 }
----






==== Ellipse
In the following example a new function is created by modifying the existing function called Circle to become a function Ellipse. Circle is a standard function provided by Cascade Studio in its library https://github.com/zalo/CascadeStudio/blob/master/js/CADWorker/CascadeStudioStandardLibrary.js. This function looks like this: 

[source, javascript]
----
function Circle(radius, wire) {
  let curCircle = CacheOp(arguments, () => {
    let circle = new oc.GC_MakeCircle(new oc.gp_Ax2(new oc.gp_Pnt(0, 0, 0),
      new oc.gp_Dir(0, 0, 1)), radius).Value();
    let edge = new oc.BRepBuilderAPI_MakeEdge(circle).Edge();
    let circleWire = new oc.BRepBuilderAPI_MakeWire(edge).Wire();
    if (wire) { return circleWire; }
    return new oc.BRepBuilderAPI_MakeFace(circleWire).Face();
  });
  sceneShapes.push(curCircle);
  return curCircle;
}

Extrude(Circle(10,false),[0,0,20])
----

With some researching into the options of the OpenCascade Library, see https://dev.opencascade.org/doc/refman/html/class_g_c___root.html other functions provided by OpenCascade can be found. If we compare the function GC_MakeEllipse with GC_MakeCircle we can see that they are quite similar, except for the fact that an ellipse is defined by two radii instead of one. As a first experiment we take the function for Circle, change every occurence of the word Circle into Ellipse and add one extra parameter to its call. We then get: 

[source, javascript]
----
function Ellipse(radius1, radius2, wire) {
  let curEllipse = CacheOp(arguments, () => {
    let ellipse = new oc.GC_MakeEllipse(new oc.gp_Ax2(new oc.gp_Pnt(0, 0, 0),
      new oc.gp_Dir(0, 0, 1)), radius1, radius2).Value();
    let edge = new oc.BRepBuilderAPI_MakeEdge(ellipse).Edge();
    let ellipseWire = new oc.BRepBuilderAPI_MakeWire(edge).Wire();
    if (wire) { return ellipseWire; }
    return new oc.BRepBuilderAPI_MakeFace(ellipseWire).Face();
  });
  sceneShapes.push(curEllipse);
  return curEllipse;
}

Extrude(Ellipse(30,15,false),[0,0,20])
----

This works like a charm! Note that in theory an ellipse can also be obtained by scaling a circle in one direction only. However, the Scale function currently only allows a uniform scale change. 


==== RegularPolygon
The function RegularPolygon can be used to draw a regular polygon. The first parameter indicates the radius of the polygon (i.e. the radius of the inscribed circle that would pass through each of the corners of the polygon), the second parameter indicates the number of corners. The shape is always centered around the origin. 

[source, javascript]
----
function RegularPolygonPoints(radius, numPoints) {
    const points = []
    for (let theta = 0; theta < 2*Math.PI; theta += 2*Math.PI / numPoints) 
    {
        points.push([Math.cos(theta) * radius, Math.sin(theta) * radius, 0])
    }
    return points
}

function RegularPolygon(radius, numPoints)
{
    return Polygon(RegularPolygonPoints(radius, numPoints))
}
----

Note that this code is directly derived from https://cadhub.xyz/u/franknoirot/Incribed-Polygon. 

== Interface items

=== Slider
Creates a simple slider that can be used to adjust parameters of the model. The function specifies defaults, minimum and maximum ranges. 

[source, javascript]
----
// Slider(name = "Val", defaultValue = 0.5, min = 0.0, max = 1.0, realTime=false, step, precision)
let currentSliderValue = Slider("Radius", 30 , 20 , 40); // name needs to be unique!
----

The callback of this function triggers whenever the mouse is let go, and realTime will cause the slider to update every frame that there is movement (but it's buggy!). The parameter step controls the amount that the keyboard arrow keys will increment or decrement a value. This parameter defaults to 1/100 (0.01).

=== Checkbox
This function creates a checkbox in the dialog of the 3D window that can be used to turn features on and off. The function returns a boolean value (true/false) that can be used in an if-statement in your code to determine which part of the code should be executed. 

[source, javascript]
----
// Checkbox(name: string, defaultValue: boolean): boolean
let currentCheckboxValue = Checkbox("Check?", true);
---- 


=== Button
The Button function can be used to add an extra button to the dialog screen in the 3D window. According to the help in the editor window the function can be used to trigger a specific action: 

[source, javascript]
----
// Button(name = "Action")
Button("Yell", ()=>{console.log("Help! I've been clicked!"); });
----

However, it seems that the button can only be used to start processing the script. The button then acts as a copy of the Evaluate button that is always available in the dialog window. 

=== SaveFile
The function SaveFile can be used to write the result of a script directly to a file. Normally this function is not needed, as in most cases you first inspect the result of the script in the 3D window and then use the menu to save the file. 

[source, javascript]
----
// SaveFile(filename, fileURL)
SaveFile("myInfo.txt", URL.createObjectURL( new Blob(["Hello, Harddrive!"], { type: 'text/plain' }) ));
----

== Modifying CascadeStudio
As the code of CascadeStudio is available, it is possible to change items to your personal preferences. In this section some options for changes to the interface will be highlighted. Note that these changes are only possible if you run your own version of Cascade Studio with a live server.   

=== Modifying the panel lay-out
When the program is started, the editor window is on the left, the 3D view on the right and the console log in the bottom of the 3D view. It is possible to adjust the position of the dividers between the panels but also to grab the tab of each panel and drag it to a completely different position. It is even possible to drag tabs into the same panel, for example to hide the console log behind the editor. 


image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/changed_interface_layout.png[width=500]






=== Change the initial code shown after startup

After startup, CascadeStudio always contains a small piece of code that produces the logo of the program. This code is contained in the file `CascadeStudio/js/MainPage/CascadeMain.js`. You can find the relevant code by searching for the text `let starterCode = `. If you enter your own code here this will be shown after startup of your local version. 

=== Modifying the 3D view
The view can be modified using the code in `CascadeStudio/js/MainPage/CascadeView.js`. The code blocks below show the relevant pieces of code. The comment lines contain some examples of different colours that can be used.

[source, javascript]
----
this.backgroundColor  = 0x222222; // light: 0xa0a0a0  def: 0x222222  blue: 0xb5dcff
----

[source, javascript]
----
this.groundMesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2000, 2000),
      new THREE.MeshPhongMaterial({
        color: 0x61b87a, depthWrite: true,   //def: 0x080808
----

image::https://github.com/raydeleu/CascadeStudioManual/blob/main/images/changed_floor_background.png[width=500]

In the example above not only the colour of the background and floor were changed, but also the socalled `matcap` that determines how the 3D shape is rendered in the studio lights. The `matcap` is a small image file contained in the directory `CascadeStudio/textures/`. If you look on the internet for matcap files you can find many examples. In the image above I used the `red car paint` matcap from Blender (https://www.blender.org). Examples for matcap files can be found in https://devtalk.blender.org/t/call-for-content-matcaps/737. 

To see a different matcap you can change the name of your new matcap file into `dullFrontLitMetal.png`. If you want it a bit easier to change the file, adapt the file name `dullFrontLitMetal.png` in the code sample below into something like `matcap.png`. When you want to load a different matcap, place the image file in the directory `CascadeStudio/textures/`, make a copy and rename it to matcap.png. When you want a different matcap, just delete the file `matcap.png` and repeat the process for a different image file. Remember to always create a copy of your image file, else you may have deleted your favourite matcap. 

[source, javascript]
----
 // Load the Shiny Dull Metal Matcap Material
  this.loader = new THREE.TextureLoader(); this.loader.setCrossOrigin ('');
  this.matcap = this.loader.load('./textures/dullFrontLitMetal.png', (tex) => { this.environment.viewDirty = true; } );
  
----


== Shortcut keys
=== General

[cols="1,1"]
|===
kbd:[F5]	| Recalculate/Render
|===


=== Editor


[cols="1,1"]
|===
| kbd:[F1]		| Open command palette
| kbd:[F8]		| Show errors in code
| kbd:[F12]		| Go to definition
| kbd:[CMD] + kbd:[F]	| Find
| kbd:[CMD] + kbd:[E]	| Find selected text 
| kbd:[ENTER]		| Find next
| kbd:[ALT] + kbd:[UP] 	| Move line up
| kbd:[ALT] + kbd:[DN] 	| Move line down
| kbd:[CTRL] + kbd:[Space] | Trigger suggestion/info
| kbd:[CMD] + kbd:[]]  | Indent
| kbd:[CMD] + kbd:[[]  | Outdent
| kbd:[ALT] + kbd:[DN] 		| 	Move line down
| kbd:[ALT] + kbd:[DN] 		| 	Move line down
| kbd:[CMD] + kbd:[/]		| Toggle comment line 
| kbd:[SHIFT] + kbd:[ALT] + kbd:[A] | Toggle block comment
| kbd:[SHIFT] + kbd:[ALT] + kbd:[UP] | Copy line up
| kbd:[SHIFT] + kbd:[ALT] + kbd:[DN] | Copy line down
|===

== Comparison to similar tools



== A short introduction to Javascript

=== How to learn to program? 
For this manual it is assumed that the reader has at least some programming experience. If not, then there are plenty of tutorials available on-line to get some experience in programming. It is difficult to give some advice on which programming language should be the first choice when learning to program. The Python programming language is probably a good starting point for many people as this is a relatively simple language that can be used for both small scripts - even as a small calculator inside a console window - and large programs. Python is also used extensively as a scripting language for other software packages. For example for people that are interested in 3D modelling two other interesting programs are Freecad (https://www.freecadweb.org/) and Blender (https://www.blender.org/). Both programs can be extended using Python scripts. When working on MacOS, Python is already pre-installed. Opening a console window and typing "python" or "python3" is sufficient to get a socalled interactive session to run Python scripts. When working on Windows or Linux it is probably necessary to install Python. Go to https://www.python.org/ to find your options for each operating system. 

Another interesting choice, especially when you want to work with CascadeStudio, is to use Javascript. Javascript is a scripting language that is used often in web pages. When you are reading this in a web browser, you already have software available to run Javascript. 

And of course you can also start to program using CascadeStudio! Many of the general concepts of programming will be necessary to work with CascadeStudio and if you start with small examples and build from them, you will automatically learn more and more of the programming language. 

https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/JavaScript_basics
https://www.w3schools.com/js/default.asp



=== Variables
Javascript variables may be considered to be containers for data values. A variable can be declared with the keyword `var`, `let` or `const`. The keyword `var` was used before 2015 and is most widely supported. The more modern version is to use `let` for variables with a restricted scope - so for example if they are declared inside a function they are only available within that function - and the keyword `const` to define a variable that will never be reassigned. For example, the conversion factor between feet and meters can be declared as a `const` as this will never change, whereas the length of a car should be defined using `let`.  

[source, javascript]
----
let rateHour = 30 ;
let hoursWeek = 36 ;
let rateWeek   = rateHour * hoursWeek
console.log(rateWeek)
console.log(typeof rateWeek)
----

Once the variable is declared it can be used without the keyword. Note that opposed to many other programming languages it is not necessary to determine the type of variable up front. The declaration of the type of the variable is performed implicit by assigning a value. The `typeof` function can be used to determine the type of a variable. 

=== Operations

The following math operations are supported:

Addition +,
Subtraction -,
Multiplication *,
Division /,
Remainder %,
Exponentiation **

precedence standard

Modify-in-place
We often need to apply an operator to a variable and store the new result in that same variable.

For example:

let n = 2;
n = n + 5;
n = n * 2;
This notation can be shortened using the operators += and *=:

let n = 2;
n += 5; // now n = 7 (same as n = n + 5)
n *= 2; // now n = 14 (same as n = n * 2)

alert( n ); // 14

Greater/less than: a > b, a < b.
Greater/less than or equals: a >= b, a <= b.
Equals: a == b, please note the double equality sign == means the equality test, while a single one a = b means an assignment.
Not equals. In maths the notation is , but in JavaScript its written as a != b.

=== Conditions and loops

if (condition) {   } else {  } 

for (let i=0 ; i<=n ; i++){   }

----
=== equality without type conversion
== equal
> < => <=
|| OR
&& AND
! NOT (result = !value)
----


=== Comments 


=== Functions


=== Modules



=== Objects
Javascript can use objects to define data and methods that can be applied to these data. This can look like: 

[source,javascript]
---
let car = {type:"Tesla", power:"Electricity", color: white, length:5.1 };
---

The result of this assignment is that: 

[source,javascript]
---
car.type = Tesla
car.length = 5.1
---

We can also assign methods to objects. Methods are functions that describe the behaviour of an object. So for example a method for a car could be start(), charge(), stop(). 

In CascadeStudio we encounter this approach in the definition of sketches. Each sketch is a new object, hence the declaration `new Sketch`. Then we apply methods to the sketch to let the sketch grow. For example, with the methods `.LineTo()` we call the LineTo method of the object. 
In the definition of a function we can use the `this` keyword for the method to refer to the owner of the method. `This` always refers to the local object or the current parent of a function. 






	
